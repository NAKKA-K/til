# Go lang is array
Go言語には固定長の配列(array)があります。  

## 宣言
```go
var a [2]int
a[0] = 1

a := [2]int{0, 1}

a := [...]int{0, 1}  // int配列を作成し、その配列への参照を渡すスライス

var a [2]int
a = [4]int{1, 2, 3, 4}  // コンパイルエラー: [4]intを[2]intに代入できない
```

配列はインデックス値を指定して宣言することもできます。  
それには複数の便利な利用法があります。  
1つは宣言する配列の各値に明確な意味が決まっている場合に、インデックスを定数で表すことによって分かりやすくすることができます。  

```go
type Currency int
const(
    USD Currency = int
    RMB
)
symbol := [...]string{USD: "$", EUR: "€"}
fmt.Println(RMB, symbol[RMB])  // 1 €
```

この形式ではどの順序でもインデックスを書くことができます。  

```go
    r := [...]int{99: -1}
```


## Slice
スライスとはGo言語における可変長配列の一部です。  
スライスは配列への参照を保持しているのみで、データ自体を保持していません。  
スライスの参照から値を変更すると、参照先の配列の値も変更されます。  
```go
sc := a[1:3]

board := [][]string{
    []string{"_", "_", "_"},
    []string{"_", "_", "_"},
    []string{"_", "_", "_"},
}
```


スライスにはlen(長さ)とcap(容量)が存在します。  
容量は参照先の配列の長さ(参照している位置より後ろの配列長)を返す。  
長さはスライス自体が持っている長さ。  
```go
len(a)
cap(a)
```


スライスの初期値はnilで、lenとcapが0です。  
nil比較する場合は`sc == nil`で判定できる。  
だがprint表示すると`[]`の形で表示されるため頭に入れておく必要がある。  


スライスの動的生成にはmake関数を使うことができます。  
```go
sc := make([]int, 5)  // len(sc)=5, cap(sc)=5
sc := make([]int, 0, 5)  // len(sc)=0, cap(sc)=5
tmp := sc[:cap(sc)]
```


スライスへ新しい要素追加するにはappend関数を使用します。  
スライスへのappend関数を使用した時に、追加長が容量以内であれば新しくスライスし直して値を返す。  
追加長が容量を超えて入れば、新しく配列を生成し直して値を返す。
```go
var sc []int  // => []
sc = append(sc, 1)  // => [1]
```


