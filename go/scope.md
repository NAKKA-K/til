# scope
Go言語でのスコープは、色々と気をつける必要があります。  


## ブロックの種類
レキシカルブロック(ローカル)とユニバースブロック(グローバル)があります。  
レキシカルブロックはifやswitch、関数などで存在します。  
ユニバースブロックは組み込み変数などを持っています。  

## スコープ範囲
スコープは自分の宣言されたブロックの中で存在します。  
たとえば同じ名前の変数の片方が、もう片方の変数のスコープより狭い範囲で宣言された場合、その狭い範囲の中ではそちらの変数が有効になり、外の変数にはアクセスされなくなります。  


## スコープ範囲が特殊な記法
たとえばif文の省略宣言です。  
以下の場合、ifの判定部で省略宣言した変数はelse文の中でも有効なスコープになります。  
if文が終わるとそのスコープ範囲外です。  
これはswitch文でも同様になります。  

```go
if f, err := os.Open(fname); err != nil {
    return err
}else{
    f.Stat()
    f.CLose()  // 正常に参照できる
}
fmt.Println(f)  // 範囲外参照でエラー
```

## 狭いスコープでの変数再宣言
パッケージレベルの変数と同じ名前の変数を、ある関数内で省略宣言した場合に発生する分かり辛い動作があります。  
省略宣言されるときに、パッケージレベルの変数ではなく、関数内スコープの変数として再宣言されてしまうことによって不安な挙動をしてしまいます。  
この動作の防止方法は、関数内で先にerr変数を宣言しておき、省略宣言構文を使わずに=で代入する式に書き換えることです。  

```go
var cwd string
func init(){
    cwd, err := os.Getwd()  // cwdの未使用でコンパイルエラー
    if err != nil{
        log.Fatalf("os.Getwd failed: %v", err)
    }
}
```
