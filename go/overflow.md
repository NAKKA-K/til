# overflow
Go言語では明示的な数値計算でのオーバーフローが出れば、コンパイル時エラーでコンパイルできません。  
ですが、変数に格納した値同士の計算であれば特にチェックされずにコンパイルされます。  
その仕組みを利用して、実行時にオーバーフローを意図的に発生させてビット演算をすると、オーバーフローした時の値が0のため有用なアルゴリズムとして使用できます。  

```go
var pc [256]byte

func init() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&1)
	}
}

// xの1が立っているビットの数を返してくれます。
// byteは8bitしか容量がないため、それ以上の値をキャストするとオーバーフローが発生し、範囲外を計算せずに値を出す。
// しかし数値で直接オーバーフローするようなコードを書いた場合には、コンパイルエラーが発生する。  
func PopCount(x uint64) int {
	return int(pc[byte(x>>(0*8))] +
		pc[byte(x>>(1*8))] +
		pc[byte(x>>(2*8))] +
		pc[byte(x>>(3*8))] +
		pc[byte(x>>(4*8))] +
		pc[byte(x>>(5*8))] +
		pc[byte(x>>(6*8))] +
		pc[byte(x>>(7*8))])
}

/* pcの初期化値
0 1 1 2 1 2 2 3   (7)  // オーバーフローした場合やビットが立っていない場合にはビット数を0として、配列のインデックス0にアクセスするため先頭のみ0
1 2 2 3 2 3 3 4   (15)
1 2 2 3 2 3 3 4   (23)
2 3 3 4 3 4 4 5   (31)
1 2 2 3 2 3 3 4   (39)
2 3 3 4 3 4 4 5   (47)
2 3 3 4 3 4 4 5   (55)
3 4 4 5 4 5 5 6   (63)
1 2 2 3 2 3 3 4   (71)
2 3 3 4 3 4 4 5   (79)
2 3 3 4 3 4 4 5   (87)
3 4 4 5 4 5 5 6   (95)
2 3 3 4 3 4 4 5   (103)
3 4 4 5 4 5 5 6   (111)
3 4 4 5 4 5 5 6   (119)
4 5 5 6 5 6 6 7   (127)
1 2 2 3 2 3 3 4   (135)
2 3 3 4 3 4 4 5   (143)
2 3 3 4 3 4 4 5   (151)
3 4 4 5 4 5 5 6   (159)
2 3 3 4 3 4 4 5   (167)
3 4 4 5 4 5 5 6   (175)
3 4 4 5 4 5 5 6   (183)
4 5 5 6 5 6 6 7   (191)
2 3 3 4 3 4 4 5   (199)
3 4 4 5 4 5 5 6   (207)
3 4 4 5 4 5 5 6   (215)
4 5 5 6 5 6 6 7   (223)
3 4 4 5 4 5 5 6   (231)
4 5 5 6 5 6 6 7   (239)
4 5 5 6 5 6 6 7   (247)
5 6 6 7 6 7 7 8   (255)
*/
```

